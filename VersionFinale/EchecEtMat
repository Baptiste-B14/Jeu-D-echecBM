 public static boolean echecEtMat(int[][] tblanc, int [][] tnoir, int couleur, int tour){
        // On parcourt toutes les pièces du joueur ennemi pour voir si chacun de leur déplacement
        // ne permettrait pas d'éviter l'échec du roi
        int x, y;
        // On déclare les tableaux fictifs
        int[][] tabJoueur = new int[16][2];
        int[][] tabEnnemi = new int[16][2];
        //
        //
        //
        // On met les tableaux fictifs à la valeur des tableaux permanents
        if (tour % 2 == 0) {    //copie par for

                for(int i = 0; i<tblanc.length; i++){
                    tabJoueur[i] = tblanc[i];
                    tabEnnemi[i] = tnoir[i];
                }

        }else {
                for(int i = 0; i<tblanc.length; i++){
                    tabJoueur[i] = tnoir[i];
                    tabEnnemi[i] = tblanc[i];
         }

        }
        //
        //
        //
        // On cherche à parcourir les 64 cases de l'échiquier
        for (int case=0; case<64; case++){
            // On prend les coordonnées de chaque case
            int x=case/8;
            int y=case%8;
            // On parcourt les 16 pièces de l'ennemi
            for (int indicePiece=0; indicePiece<16; indicePiece++)
                // On s'assure que la pièce manipulée n'est pas hors-jeu :
                if (tabEnnemi[indicePiece][0]>=0)
                    // On vérifie si la pièce peut aller aux coordonnées de la case(x;y)
                    if (caseDisponible(x, y, couleur, tnoir, tblanc) && verificationDeplacementPossible(tabJoueur, tabEnnemi, indicePiece, x, y, couleur) && verificationDuChemin(indicePiece, x, y, couleur, tabJoueur, tabEnnemi)) {
                        actualisationEchiquier(x, y, indicePiece, couleur, tabJoueur, tabEnnemi);
                        if (!echecRoi(couleur, tabJoueur, tabEnnemi))
                            return false;

                        // On ré-actualise les tableaux d'origine 
                        // Pour ne pas enregistrer le déplacement fictif de la pièce
                        if (tour % 2 == 0) {    //copie par for

                            for(int i = 0; i<tblanc.length; i++){
                                tabJoueur[i] = tblanc[i];
                                tabEnnemi[i] = tnoir[i];
                            }

                        }else {
                            for(int i = 0; i<tblanc.length; i++){
                                tabJoueur[i] = tnoir[i];
                                tabEnnemi[i] = tblanc[i];
                            }

                        }
                        
                    }
        }
        return true;
    }
